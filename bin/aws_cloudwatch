#!/usr/bin/env python
import boto.ec2.cloudwatch
import datetime
import time
import sys
import os
import socket
import getopt

import pprint

def usage():
    sys.stderr.write("""Check_MK AWS Cloudwatch Data Source

USAGE: aws_cloudwatch [OPTIONS] NAMESPACE DIMENSION
       aws_cloudwatch -h

ARGUMENTS:
  NAMESPACE                       AWS Cloudwatch namespace
  DIMENSION                       AWS Cloudwatch dimension to select

OPTIONS:
  -h, --help                      Show this help message and exit
  -p MINUTES, --period MINUTES    metric period, default is 1 minute
  -a, --agent                     Also retrieve data from the normal Check_MK Agent.
                                  This makes sense if you query a EC2 instance that
                                  you also want to Monitor with Check_MK.
  -t, --timeout SECS              Set the network timeout when connecting the agent (option -a).
                                  Default is 60 seconds.
  --debug                         Debug mode: let Python exceptions come through
  -i MINUTES, --interval MIUNTES  metric query time interval, default is 15 minutes

""")

def simple_livestatus_query(lql):
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(livestatus_unix_socket)
    s.send(lql)
    s.shutdown(socket.SHUT_WR)
    response = ""
    while True:
        chunk = s.recv(4096)
        if not chunk:
            break
        response += chunk
    return response

def get_agent_info_tcp(address):
    response = ""
    try:
        ipaddress = socket.gethostbyname(address)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.settimeout(opt_timeout)
        except:
            pass # some old Python versions lack settimeout(). Better ignore than fail
        s.connect((ipaddress, 6556))
        try:
            s.setblocking(1)
        except:
            pass
        response = ""
        while True:
            out = s.recv(4096, socket.MSG_WAITALL)
            if out and len(out) > 0:
                response += out
            else:
                break
        s.close()
        return response
    except Exception, e:
        if opt_debug:
            raise
    return response

short_options = 'hi:at:p:'
long_options  = [
    'help', 'agent', 'debug', 'timeout=', "period=", "interval="
]

opt_debug               = False
opt_agent               = False
opt_timeout             = 60
opt_period              = 1
opt_interval            = 15
livestatus_unix_socket  = os.path.expanduser("~/tmp/run/live")

try:
    opts, args = getopt.getopt(sys.argv[1:], short_options, long_options)
except getopt.GetoptError, err:
    sys.stderr.write("%s\n" % err)
    sys.exit(1)

for o,a in opts:
    if o in [ '--debug' ]:
        opt_debug = True
    elif o in [ '-a', '--agent' ]:
        opt_agent = True
    elif o in [ '-p', '--period' ]:
        opt_period = int(a)
    elif o in [ '-i', '--modules' ]:
        opt_interval = int(a)
    elif o in [ '-t', '--timeout' ]:
        opt_timeout = int(a)
    elif o in [ '-h', '--help' ]:
        usage()
        sys.exit(0)

if len(args) == 2:
    namespace = args[0]
    dim_key, dim_arg = args[1].split("=")
else:
    sys.stderr.write("ERROR: Please specify namespace and dimension.\n")
    sys.exit(1)

socket.setdefaulttimeout(opt_timeout)
region = boto.ec2.cloudwatch.CloudWatchConnection.DefaultRegionName

if namespace == "AWS/EC2":
    response = simple_livestatus_query("GET hosts\nColumns: alias address\nFilter: name = %s\n" % dim_arg)
    dim_value, ip = response.strip().split(";")
    print get_agent_info_tcp(ip)
else:
    dim_value = dim_arg.split(".")[0]

c = boto.ec2.cloudwatch.connect_to_region(region)

metrics = c.list_metrics(namespace=namespace, dimensions = { dim_key: dim_value })

if metrics:
    end=datetime.datetime.utcnow()
    start =  end - datetime.timedelta(minutes = opt_interval)

    print "<<<aws_cloudwatch>>>"

    datapoints = [ (m, m.query(start, end, m.Statistics, None, opt_period * 60)) for m in metrics ]
    for (m, q) in datapoints:
        if q and m.name != "SentMessageSize":
            r = sorted(q, key = lambda k: k['Timestamp'], reverse = True)[0]
            print m.name, r['Timestamp'].strftime("%s"), r['SampleCount'], r['Unit'], r['Average'], r['Maximum'], r['Minimum'], r['Sum']
